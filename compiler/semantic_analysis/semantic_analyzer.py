from compiler.datastructures.AST import ast_factory_nodes as fn
from compiler.semantic_analysis.visitors.symbol_table_creation_visitor import SymbolTableCreationVisitor
from compiler.semantic_analysis.visitors.compute_mem_size_visitor import ComputerMemSizeVisitor
from compiler.semantic_analysis.visitors.code_generation_visitor import CodeGenerationVisitor
from compiler.datastructures.symbol_table import SymbolTable
from terminaltables import AsciiTable


class SemanticAnalyzer:
    def __init__(self, ast_root_node: fn.Node):
        self.ast_root_node = ast_root_node
        self.global_table = None

    def analyze(self) -> None:
        """"
        Driver method for semantic analysis of AST generated by parser.
        """
        # Init visitors
        table_creation_visitor = SymbolTableCreationVisitor()
        mem_size_visitor = ComputerMemSizeVisitor()
        code_generation_visitor = CodeGenerationVisitor()

        # Create Tables
        self.ast_root_node.accept(table_creation_visitor)
        self.global_table = self.ast_root_node.symb_table
        # Compute memory sizes
        self.ast_root_node.accept(mem_size_visitor)
        # Generate Code
        self.ast_root_node.accept(code_generation_visitor)

        with open('output/compiled.m', 'w') as f:
            f.write(code_generation_visitor.moon_exec_code)
            f.write(code_generation_visitor.moon_data_code)

    def output_tables(self, root_table: SymbolTable) -> str:
        """
        Recursively traverses the symbol tables and generates a formatted string of their content.

        :param root_table: Root symbol table for current iteration
        :return: str
        """
        title: str = root_table.name + '  |  ' + str(root_table.table_size)
        data = [
            ['Name', 'Kind', 'Type', 'Link']
        ]

        # Set up table data
        for s in root_table.symbols:
            row = [
                s.element_name,
                s.element_kind,
                s.element_type
            ]

            if s.element_link is not None:
                row.append("\u2714")
            else:
                row.append("\u2A2F")

            data.append(row)

        # Generate Table
        padding: str = ""

        for i in range(0, root_table.table_level):
            padding += '\t'

        table = AsciiTable(data, title)
        output = table.table.replace('\n', '\n'+padding)
        # print(padding+output)
        output = padding + output + '\n'

        # Generate children
        for s in root_table.symbols:
            if s.element_link is not None:
                output += self.output_tables(s.element_link)

        return output

    def log_results(self, to_file: bool=False, root_node: SymbolTable=None) -> None:
        """
        Log semantic analysis results to screen and optionally to a file.

        :param to_file: Boolean to state whether logging should also write to file
        :param root_node: start of symbol tables to log
        :return: None
        """
        if root_node is None:
            root_node = self.global_table

        file: str = "output/symbol_tables"
        content: str = self.output_tables(root_node)

        if to_file:
            with open(file, 'w') as f:
                f.write(content)

        print(content)

